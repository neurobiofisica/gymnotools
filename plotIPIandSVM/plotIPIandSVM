#!/usr/bin/env python
# -*- coding: utf-8 -*-

import struct, sys, os, subprocess, inspect
from operator import itemgetter
import argparse

import matplotlib
matplotlib.use("Qt5Agg")

import numpy as np

import matplotlib.pyplot as plt
from matplotlib.mlab import find
from matplotlib.ticker import FuncFormatter
from matplotlib.widgets import Button
from matplotlib.backend_bases import MouseEvent, KeyEvent
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar

from PyQt5 import QtCore, QtGui, QtWidgets
from graphicalInterface import Ui_Dialog #########
from IPIWindow import IPIWindow #########

import sys
if sys.version_info.major == 3:
    xrange = range
    openmode = 'b'
else:
    openmode = ''

#Be sure that is on current directory (to import and append path correctly)
os.chdir( os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe()))) )

sys.path.append( os.path.realpath('../') )
recogpath = '../recog/recog'
import recogdb

# Constants
lowSat = -9.9
highSat = 9.9

sys.path.append( os.path.abspath('..') )
from read_param import *
# import NChan, freq, winSize

# Defines (zorder -> used of selecting picker)
IPIDATABLUE = 100 # The dots will be on top of every other plot
IPIDATARED = 200
LEGENDIPI = 3
LEGENDBLUE = 4
LEGENDRED = 5
SCATTER = 6
OPTIONS = 7

FIGIPI = 1
FIGSIG = 2

SPKSIZE = winSize
DEFAULTSUR = int(freq*0.100) # s


###### Auxiliary funcs ####

# Auxiliary function for reading
def parseSVMFlags(f, col=4):
    flags = []
    for line in f.readlines():
        flags.append( line.split()[col] )
    return flags

# make a color from number
# base is a list containing the chars 'r','g','b'
def num2color(num, base):
    c = hex(num)[2:].rjust(2,'0')
    out = '#'
    if 'r' in base:
        out = out + c
    else:
        out = out + '00'
    if 'g' in base:
        out = out + c
    else:
        out = out + '00'
    if 'b' in base:
        out = out + c
    else:
        out = out + '00'
    return out

# Argument parser

class MyParser(argparse.ArgumentParser): # Prints help message in case of error
    def error(self, message):
        self.print_help()
        sys.stderr.write('\nerror: %s\n' %message)
        sys.exit(2)

# Deactivate keyboard shortcuts of matplotlib
for v in plt.rcParams.keys():
    if 'keymap' in v:
        plt.rcParams[v] = ''
# Old legend behavior
matplotlib.rcParams['legend.fancybox'] = False
matplotlib.rcParams['legend.loc'] = 'upper right'

class PickPoints:
    lock = None
    def __init__(self, plotObject, ipifilename):

        self.plotObject = plotObject
        self.fig = plotObject.fig
        self.ax = plotObject.ax

        self.sigfig = plotObject.sigfig

        self.dialogIPI = plotObject.dialogIPI
        
        self.ipifilename = ipifilename

        # Auxiliary plots for legend
        self.ax.plot([], 'k-', lw=2, label='\'i\' IPI on', zorder=LEGENDIPI)
        self.ax.plot([], 'b.-', mew=2, label='\'b\' Blue on', zorder=LEGENDBLUE)
        self.ax.plot([], 'r.-', mew=2, label='\'r\' Red on', zorder=LEGENDRED)
        self.ax.plot([], 'ko', mew=5, label='\'d\' Dots on', zorder=SCATTER)
        self.ax.plot([], 'w.', label='\'o\' Options off', zorder=OPTIONS)
        self.ax.legend()
        handles, labels = self.ax.get_legend_handles_labels()

        self.cidpick = self.fig.canvas.mpl_connect('pick_event', self.onpick)
        self.cidpress = self.fig.canvas.mpl_connect('key_press_event', self.press)
        self.cidzoom = self.fig.canvas.mpl_connect('scroll_event', self.zoom)
        self.cidbpress = self.fig.canvas.mpl_connect('button_press_event', self.button_press)
        self.cidmotion = self.fig.canvas.mpl_connect('motion_notify_event', self.on_motion)
        self.cidbrelease = self.fig.canvas.mpl_connect('button_release_event', self.button_release)

        self.cidsigscroll = self.sigfig.canvas.mpl_connect('scroll_event', self.sig_scroll)
        self.cidsigrelease = self.sigfig.canvas.mpl_connect('button_release_event', self.sig_release)
        self.cidsigmotion = self.sigfig.canvas.mpl_connect('motion_notify_event', self.sig_on_motion)

        self.b = True
        self.r = True
        self.svm = False
        self.ipi = True
        self.options = False
        #self.plotObject.scatterFlag = True # Ja inicializado na classe PlotData

        self.initialPos = None


        self.dicHandles = {}

        for h in handles:
            if h.zorder == LEGENDBLUE:
                self.dicHandles.update( {'b':h} )
            elif h.zorder == LEGENDRED:
                self.dicHandles.update( {'r':h} )
            elif h.zorder == LEGENDIPI:
                self.dicHandles.update( {'IPI':h} )
            elif h.zorder == SCATTER:
                self.dicHandles.update( {'Dots':h} )
            elif h.zorder == OPTIONS:
                self.dicHandles.update( {'Options':h} )

        self.ind = 0
        self.ylim = self.ax.get_ylim()
        self.end = self.ax.get_xaxis().get_data_interval()[1]
        self.make_buttons()

    def make_buttons(self):
        self.fig.subplots_adjust(bottom=0.15)

        axprev = self.fig.add_axes([0.001, 0.005, 0.1, 0.07])
        axhome = self.fig.add_axes([0.111, 0.005, 0.1, 0.07])
        axnext = self.fig.add_axes([0.221, 0.005, 0.1, 0.07])
        axupdate = self.fig.add_axes([0.521, 0.005, 0.1, 0.07])
        axzoom = self.fig.add_axes([0.899, 0.006, 0.1, 0.07])
        self.bnext = Button(axnext, 'Next')
        self.bnext.on_clicked(self.next)
        self.bprev = Button(axprev, 'Previous')
        self.bprev.on_clicked(self.prev)
        self.bupdate = Button(axupdate, 'Update')
        self.bupdate.on_clicked(self.updateSig)
        self.bhome = Button(axhome, 'Home')
        self.bhome.on_clicked(self.home)

        self.zoomStatus = 'X'

        self.bzoom = Button(axzoom, self.zoomStatus + ' Zoom')
        self.bzoom.on_clicked(self.click_zoom)

        self.fig.canvas.draw()

    def onpick(self,event):
        if event.mouseevent.button != 1:
            return

        try:
            self.plotObject.pltsvmstrongB.pop(0).remove()
        except:
            pass
        try:
            self.plotObject.pltsvmstrongR.pop(0).remove()
        except:
            pass

        zorder = event.artist.zorder
        if self.ipi == True and (\
                (zorder == IPIDATABLUE and self.b == True) or \
                (zorder == IPIDATARED and self.r == True)):

            ind = event.ind[0]

            if self.plotObject.isScatter == False:
                xdata = event.artist.get_xdata()
            else:
                data = event.artist.get_offsets()
                xdata = [x for x,y in data]

            sample = int(round(xdata[ind]*freq))
            key = self.plotObject.offsDic[sample]
            ret = recogdb.readHeaderEntry(self.plotObject.db,key)
            if ret is not None:
                off, data, spkwin = ret
            else:
                off, data, spkwin = None, None, None

            if zorder == IPIDATABLUE:
                color = 'b'

                # Draw a line over the point
                self.plotObject.pltsvmstrongB = self.ax.plot([sample/freq,sample/freq],self.plotObject.SVMY0[:2],'b-', lw=1)

            elif zorder == IPIDATARED:
                color = 'r'

                # Draw a line over the point
                self.plotObject.pltsvmstrongR = self.ax.plot([sample/freq,sample/freq],self.plotObject.SVMY1[:2],'r-', lw=1)

            if off is not None:
                Parameters = ( data[ recogdb.dicFields['presentFish'] ], \
                    self.plotObject.sec2hms(sample / freq, None), \
                    off, \
                    data[ recogdb.dicFields['direction'] ], \
                    data[ recogdb.dicFields['svm'] ], \
                    data[ recogdb.dicFields['probA'] ], \
                    data[ recogdb.dicFields['probB'] ], \
                    data[ recogdb.dicFields['distA'] ], \
                    data[ recogdb.dicFields['distB'] ], \
                    data[ recogdb.dicFields['distAB'] ], \
                )

            self.fig.canvas.draw() # To make SVM lines bold
            central = (xdata[ind], color)
            self.plotObject.selectedIPI = central
            self.plotObject.plotSigData()
            if self.options == True:
                if off is not None:
                    self.plotObject.dialogIPI.fillTextBoxes(Parameters)
                self.plotObject.dialogIPI.exec_()
                # Switch option to 'off' state
                self.options = not(self.options)
                self.dicHandles['Options'].set_label('\'o\' Options off')
                self.ax.legend()
                self.fig.canvas.draw()
                
                self.plotObject.dialogIPI.replot = False # TODO: GAMBIARA!!!
                if self.plotObject.dialogIPI.replot == True:
                    
                    self.plotObject.app.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
                    
                    # This is for recreating the local singlefish and probs files
                    ##### The following code was only useful when there was SVM pair, so we iterate_from on SVM borders. It is useless now.
                    """self.plotObject.loadDataFromDB()
                    
                    oldDir = os.getcwd()
                    while len(self.plotObject.dialogIPI.iterate_from) != 0:
                        
                        #Be sure that is on current directory
                        os.chdir( os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe()))) )
                        
                        direction, force, key = self.plotObject.dialogIPI.pop_iterate_from()
                        sys.stdout.write('direction %d %d %r\n'%(direction, key, force))
                        '''sys.stdout.write([recogpath, 'iterate_from', \
                                               '--saturation=%f,%f'%(self.plotObject.lowSaturation, self.plotObject.highSaturation), \
                                               '--from=%d'%key, \
                                               '--direction=%d'%direction, \
                                               '--force=%d'%force, \
                                               self.plotObject.dbname, \
                                               self.plotObject.spikesname, \
                                               self.plotObject.singlefishfilename, \
                                               self.plotObject.probsfilename])'''
                        sys.stdout.flush()
                        ret = subprocess.call([recogpath, 'iterate_from', \
                                               '--saturation=%f,%f'%(self.plotObject.lowSaturation, self.plotObject.highSaturation), \
                                               '--from=%d'%key, \
                                               '--direction=%d'%direction, \
                                               '--force=%d'%force, \
                                               self.plotObject.dbname, \
                                               self.plotObject.spikesname, \
                                               self.plotObject.singlefishfilename, \
                                               self.plotObject.probsfilename])
                        if ret != 0:
                            sys.stdout.write('ret = %d\n'%ret)
                            sys.stdout.flush()
                            assert ret == 0
                        
                        self.plotObject.db.sync()"""
                     
                    # I'll integrate the export to the loadDataFromDB  
                    """sys.stdout.write('recog export\n') #################
                    sys.stdout.flush()
                    #Be sure that is on current directory
                    os.chdir( os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe()))) )
                    
                    ret = subprocess.call([recogpath, 'export', self.plotObject.dbname, self.ipifilename])
                    if ret != 0:
                        sys.stdout.write('ret = %d\n'%ret)
                        sys.stdout.flush()
                        assert ret == 0
                    
                    self.plotObject.db.sync()
                    
                    sys.stdout.write(os.path.abspath(oldDir)+'\n')
                    sys.stdout.flush()
                    os.chdir( os.path.abspath(oldDir) )"""

                    self.plotObject.loadDataFromDB()
                    self.plotObject.formatSVM2Plot()
                    self.plotObject.formatModified2Plot()
                    
                    
                    self.plotObject.replotData()
                    self.plotObject.dialogIPI.replot = False
                    self.plotObject.app.restoreOverrideCursor()

    def press(self,event):
        key = event.key.lower()
        sys.stdout.flush()
        if key == 'b':
            self.b = not(self.b)
            if self.b == True:
                self.dicHandles['b'].set_label('\'b\' Blue on')
            else:
                self.dicHandles['b'].set_label('\'b\' Blue off')
        elif key == 'r':
            self.r = not(self.r)
            if self.r == True:
                self.dicHandles['r'].set_label('\'r\' Red on')
            else:
                self.dicHandles['r'].set_label('\'r\' Red off')
        elif key == 's':
            self.svm = not(self.svm)
            if self.svm == True:
                self.dicHandles['SVM'].set_label('\'s\' SVM on')
            else:
                self.dicHandles['SVM'].set_label('\'s\' SVM off')
        elif key == 'i':
            self.ipi = not(self.ipi)
            if self.ipi == True:
                self.dicHandles['IPI'].set_label('\'i\' IPI on')
            else:
                self.dicHandles['IPI'].set_label('\'i\' IPI off')
        elif key == 'd':
            self.plotObject.scatterFlag = not(self.plotObject.scatterFlag)
            if self.plotObject.scatterFlag == True:
                self.dicHandles['Dots'].set_label('\'d\' Dots on')
            else:
                self.dicHandles['Dots'].set_label('\'d\' Dots off')

            xlim = self.ax.get_xlim()
            ylim = self.ax.get_ylim()
            self.plotObject.plotData(xlim[0],xlim[1])
            self.ax.set_ylim(ylim)
        elif key == 'o':
            self.options = not(self.options)
            if self.options == True:
                self.dicHandles['Options'].set_label('\'o\' Options on')
            else:
                self.dicHandles['Options'].set_label('\'o\' Options off')

        elif key == 'z':
            self.zoomStatus = set(['X','Y']).difference(set(self.zoomStatus)).pop()
            self.bzoom.label.set_text(self.zoomStatus + ' Zoom')
            self.fig.canvas.draw()
        elif key == 'x':
            self.zoomStatus = 'X'
            self.bzoom.label.set_text(self.zoomStatus + ' Zoom')
            self.fig.canvas.draw()
        elif key == 'y':
            self.zoomStatus = 'Y'
            self.bzoom.label.set_text(self.zoomStatus + ' Zoom')
            self.fig.canvas.draw()
        elif key == 'right':
            self.next(event)
        elif key == 'left':
            self.prev(event)
        elif key == 'up':
            self.zoom(event)
        elif key == 'down':
            self.zoom(event)
        elif key == 'h' or key == 'escape':
            self.home(event)

        self.ax.legend()
        self.fig.canvas.draw()

    def button_press(self, event):
        if event.button != 3:
            return
        if PickPoints.lock is not None:
            return
        self.initialPos = (event.xdata, event.ydata)
        PickPoints.lock = self

    def sig_on_motion(self,event):
        if event.xdata is not None:
            X = self.plotObject.sec2hms(event.xdata, None)
            Y = self.plotObject.sec2msus(event.ydata, None)
            self.plotObject.statusBar().showMessage("<Cursor> Time: %s\t-\tVoltage: %s"%(X, Y))

    def on_motion(self, event):
        if event.xdata is not None:
            X = self.plotObject.sec2hms(event.xdata, None)
            Y = event.ydata
            self.plotObject.statusBar().showMessage("<Cursor> Time: %s\t-\tIPI: %s"%(X, Y))
        if PickPoints.lock is not self:
            return
        cur_xlim = self.ax.get_xlim()
        cur_ylim = self.ax.get_ylim()

        if event.xdata == None or event.ydata == None:
            return
        
        xdisplacement = event.xdata - self.initialPos[0]
        ydisplacement = event.ydata - self.initialPos[1]

        self.plotObject.plotData( cur_xlim[0] - xdisplacement,
                cur_xlim[1] - xdisplacement)
        self.ax.set_ylim([ cur_ylim[0] - ydisplacement,
            cur_ylim[1] - ydisplacement ])

        self.fig.canvas.draw_idle()

    def sig_scroll(self,event):
        xm, xM = self.plotObject.sigaxes[0].get_xlim()
        xmean = (xm+xM)/2.
        xran = max(abs(xmean-xm), abs(xmean-xM))
        xran = max(0.001, abs((-0.005*event.step) + xran))
        xm = xmean-xran
        xM = xmean+xran
        # All sigaxes share the X axis
        self.plotObject.sigaxes[0].set_xlim( (xm, xM) )
        self.sigfig.canvas.draw_idle()

    def sig_release(self,event):
        if event.xdata is None:
            return
        if event.button == 1:
            while len(self.plotObject.auxLines) != 0:
                self.plotObject.auxLines.pop().remove()
            for i in xrange(NChan):
                ax = self.plotObject.sigaxes[i]
                self.plotObject.auxLines.append(ax.axvline(event.xdata, color='k', lw=2, alpha=0.4))
            self.sigfig.canvas.draw_idle()
        elif event.button == 3:
            key = int(event.xdata*freq)

            dialog = QtWidgets.QMessageBox()
            dialog.setModal(True)
            dialog.setWindowTitle('Insert EOD')
            dialog.setText('Insert EOD from fish:')
            dialog.addButton(QtWidgets.QPushButton('A (Blue)'), QtWidgets.QMessageBox.YesRole) #0
            dialog.addButton(QtWidgets.QPushButton('B (Red)'), QtWidgets.QMessageBox.NoRole) #1
            dialog.addButton(QtWidgets.QMessageBox.Cancel)
            
            ret = dialog.exec_()

            if ret == QtWidgets.QMessageBox.Cancel:
                return
            elif ret == 0: # Fish A
                self.dialogIPI.modify.insertIPI(key, 1, winSize=SPKSIZE)

		#TODO: GAMBI!
                #self.plotObject.app.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
                #self.plotObject.loadDataFromDB()
                #self.plotObject.formatSVM2Plot()
                #self.plotObject.formatModified2Plot()
                
                #self.plotObject.replotData()
                #self.plotObject.app.restoreOverrideCursor()
            elif ret == 1: # Fish B
                self.dialogIPI.modify.insertIPI(key, 2, winSize=SPKSIZE)

                #self.plotObject.app.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
                #self.plotObject.loadDataFromDB()
                #self.plotObject.formatSVM2Plot()
                #self.plotObject.formatModified2Plot()
                
                #self.plotObject.replotData()
                #self.plotObject.app.restoreOverrideCursor()

    def button_release(self, event):
        if event.button != 3:
            return
        PickPoints.lock = None
        self.initialPos = None

        xlim = self.ax.get_xlim()
        Mean = (xlim[1] + xlim[0])/2.

        ClosestIndex = int(Mean / self.plotObject.stepSize)
        self.ind = ClosestIndex

        self.fig.canvas.draw()

    # Based on https://gist.github.com/tacaswell/3144287
    def zoom(self, event, base_scale=1.5):
        # get the current x and y limits
        cur_xlim = self.ax.get_xlim()
        cur_ylim = self.ax.get_ylim()
        cur_xrange = (cur_xlim[1] - cur_xlim[0])
        cur_yrange = (cur_ylim[1] - cur_ylim[0])
        xdata = event.xdata # get event x location
        ydata = event.ydata # get event y location

        if (xdata is None) or (ydata is None):
            return

        relposx = (xdata - cur_xlim[0]) / cur_xrange
        relposy = (ydata - cur_ylim[0]) / cur_yrange

        if isinstance(event, MouseEvent):
            button = event.button
        elif isinstance(event, KeyEvent):
            button = event.key
        else: #This should never happen!
            sys.stdout.write('ERROR\n')
            sys.stdout.flush()
            assert(False)

        if button == 'up':
            # deal with zoom in
            scale_factor = 1/base_scale
        elif button == 'down':
            # deal with zoom out
            scale_factor = base_scale
        else:
            # deal with something that should never happen
            scale_factor = 1
            sys.stdout.write('ERROR\n')
            sys.stdout.write('button: '+button+'\n')
            sys.stdout.flush()
            assert False
        # set new limits
        if self.zoomStatus == 'X':
            ylim = self.ax.get_ylim()
            self.plotObject.plotData( xdata - cur_xrange*scale_factor*relposx,
                    xdata + cur_xrange*scale_factor*(1-relposx) )
            self.ax.set_ylim(ylim)
        elif self.zoomStatus == 'Y':
            if cur_yrange > 2.5*self.plotObject.Mean:
                self.ax.set_ylim([ max(0,ydata - cur_yrange*scale_factor*relposy),
                    ydata + cur_yrange*scale_factor*(1-relposy)])
            else:
                self.ax.set_ylim([ ydata - cur_yrange*scale_factor*relposy,
                    ydata + cur_yrange*scale_factor*(1-relposy)])

        self.fig.canvas.draw() # force re-draw

    def click_zoom(self, event):
        self.zoomStatus = set(['X','Y']).difference(set(self.zoomStatus)).pop()
        self.bzoom.label.set_text(self.zoomStatus + ' Zoom')
        self.fig.canvas.draw()

    def update(self):
        self.plotObject.plotData( self.plotObject.stepSize*self.ind, self.plotObject.stepSize*self.ind+self.plotObject.winSize )
        self.ax.set_ylim( self.ylim )
        self.ax.get_figure().canvas.draw()

    def getIndex(self):
        xm, xM = self.ax.get_xlim()
        x = (xm + xM) / 2
        self.ind = max(0, int(x / self.plotObject.stepSize))

    def prev(self, event):
        self.getIndex()
        if self.ind > 0:
            self.ind -= 1
        else:
            self.ind = 0
        self.update()

    def next(self, event):
        self.getIndex()
        if self.plotObject.stepSize*(self.ind+1) < self.end:
            self.ind += 1
        self.update()

    def updateSig(self, event):
        self.plotObject.app.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
        self.plotObject.loadDataFromDB()
        self.plotObject.formatSVM2Plot()
        self.plotObject.formatModified2Plot()

        self.plotObject.replotData()
        self.plotObject.app.restoreOverrideCursor()

    def home(self, event):
        self.update()



class PlotData(QtWidgets.QMainWindow):
    DPI = 80

    def __init__(self, app, dbf, datafile, undoFilename, folder, ipifilename, saturation, winSize, stepSize, parent=None):
        self.app = app
        
        QtWidgets.QMainWindow.__init__(self)
        self.setAttribute(QtCore.Qt.WA_DeleteOnClose)
        self.setFocusPolicy( QtCore.Qt.ClickFocus )
        self.setFocus()
        
        self.ui = Ui_Dialog()
        self.ui.setupUi(self)
        self.ui.graphIPI.canvas.setFocusPolicy( QtCore.Qt.ClickFocus )
        self.ui.graphIPI.canvas.setFocus()

        self.mpl_toolbar = NavigationToolbar(self.ui.graphIPI.canvas, self.ui.graphIPI)

        self.resizeEvent = self.onResize
        self.showMaximized()

        self.fig = self.ui.graphIPI.canvas.fig
        self.ax = self.ui.graphIPI.canvas.ax
        self.ax.yaxis.grid()
        self.sigfig = self.ui.graphwave.canvas.fig
        self.sigaxes = self.ui.graphwave.canvas.sigaxes
        
        self.scatterFlag = True

        self.ipifilename = ipifilename

        self.undoFilename = undoFilename

        self.dbname = dbf
        self.db = recogdb.openDB(self.dbname,'w')
        
        self.folder = folder
        
        self.lowSaturation = saturation[0]
        self.highSaturation = saturation[1]
        self.winSize = winSize
        self.stepSize = stepSize
       
        # Loads on memory variables necessary for plotting
        # and dictionary from correctedSample to db off key
        #
        # Runs the whole DB
        self.loadDataFromDB()
        self.formatSVM2Plot()
        self.formatModified2Plot()
        
        self.formatterX = FuncFormatter(self.sec2hms)
        self.formatterY = FuncFormatter(self.sec2msus)

        self.plotData(0, self.winSize, plotSVM=False) # Creates self.fig and self.ui.graphIPI.canvas.ax.attributes
        self.createSigFig() # Creates self.sigfig, self.ui.graphwave.canvas.sigaxes attributes

        self.datafile = datafile
        self.TS = self.TS
        
        self.dialogIPI = IPIWindow(self.db, undoFilename, folder, self.datafile)

        self.statusBar().showMessage("")

        self.selectedIPI = None
        
    def closeEvent(self, event):
        self.db.close()
        print('')
        super(QtWidgets.QMainWindow, self).closeEvent(event)
        
    def loadDataFromDB(self):
        self.offsDic = {}
        self.correctedPosDic = {}

        P = []
        I = []
        
        P1 = []
        Modified1 = []
        direction1 = []
        SVM1 = []
        probs1 = []
        dists1 = []
        
        P2 = []
        Modified2 = []
        direction2 = []
        SVM2 = []
        probs2 = []
        dists2 = []
        
        probsdtype = [ ('svm', 'S1'), ('off1', np.int64), ('off2', np.int64), ('prob1', np.float32), ('prob2', np.float32) ]
        probsdiclist = []
        
        singlefishdtype = [ ('off1', np.int64), ('off2', np.int64) ]
        singlefishlist = []
        
        Tam1 = 0
        Tam2 = 0
        for rec in self.db.iteritems():
            key, bindata = rec
            off, = struct.unpack('q',key)
            presentFish, direction, distA, distB, distAB, flags, correctedPosA, correctedPosB, svm, pairsvm, probA, probB, spkdata = recogdb.parseDBHeader(bindata)
            probsdiclist.append( (svm, off, pairsvm, probA, probB) )

            if correctedPosA != -1:
                self.offsDic[correctedPosA] = off
                self.correctedPosDic[off] = correctedPosA
                
            if correctedPosB != -1:
                self.offsDic[correctedPosB] = off
                self.correctedPosDic[off] = correctedPosB
                
            assert ( presentFish in [1, 2, 3] )
            
            if presentFish == 1:
                Tam1 += 1
                P1.append(correctedPosA)
                P.append(correctedPosA)
                I.append(1)
                
                direction1.append(direction)
                probs1.append( (probA, probB) )
                dists1.append( (distA, distB, distAB) )
                if (svm == 's') or (svm == 'v'): # SVM or manual SVM
                    SVM1.append(correctedPosA)
                    singlefishlist.append( (off, pairsvm) ) # It is only needed to write once
                if (svm == 'm') or (svm == 'v'):
                    Modified1.append(correctedPosA)
                
            elif presentFish == 2:
                Tam2 += 1
                P2.append(correctedPosB)
                P.append(correctedPosB)
                I.append(-1)

                direction2.append(direction)
                probs2.append( (probA, probB) )
                dists2.append( (distA, distB, distAB) )
                if (svm == 's') or (svm == 'v'):
                    SVM2.append(correctedPosB)
                    ########################################## It is only needed to write once
                if (svm == 'm') or (svm == 'v'):
                    Modified2.append(correctedPosB)
                
            else:
                Tam1 += 1
                P1.append(correctedPosA)
                P.append(correctedPosA)
                I.append(1)

                direction1.append(direction)
                probs1.append( (probA, probB) )
                dists1.append( (distA, distB, distAB) )
                # 2 fish on same window is never a SVM classification
                
                Tam2 += 1
                P2.append(correctedPosB)
                P.append(correctedPosB)
                I.append(-1)

                direction2.append(direction)
                probs2.append( (probA,probB) )
                dists2.append( (distA, distB, distAB) )
                # 2 fish on same window is never a SVM classification
                
                if (svm == 'm') or (svm == 'v'):
                    Modified1.append(correctedPosA)
                    Modified2.append(correctedPosB)

        S = [i[0] for i in sorted(enumerate(P), key=lambda x:x[1])]
        P = itemgetter(*S)(P)
        I = itemgetter(*S)(I)
        ipifile = open(self.ipifilename,'w')
        for i in range(len(P)):
            ipifile.write('%d %d\n'%(I[i],P[i]))
        ipifile.flush()
        ipifile.close()
        
        self.TS = ( np.sort(np.array(P1))/freq, np.sort(np.array(P2))/freq )
        self.Modified = ( np.sort(np.array(Modified1))/freq, np.sort(np.array(Modified2))/freq )
        self.direction = ( np.array(direction1), np.array(direction2) )
        self.SVM = ( np.sort(SVM1)/freq, np.sort(SVM2)/freq )
        self.probs = (probs1, probs2)
        self.dists = (dists1, dists2)
        self.probslist = np.array(probsdiclist, dtype=probsdtype)
        self.probslist.sort(order='off1')
        self.singlefishlist = np.array(singlefishlist, dtype=singlefishdtype)
        self.singlefishlist.sort(order='off1')
        
        self.createLocalFiles()
        
    def createLocalFiles(self):
        self.probsfilename = os.path.dirname(os.path.abspath(self.undoFilename)) + '/local.probs'
        probsf = open(self.probsfilename, 'w')
        for s in self.probslist:
            probsf.write( '%s %d %d %f %f\n'%(s['svm'], s['off1'], s['off2'], s['prob1'], s['prob2']) )
        probsf.close()
        
        self.singlefishfilename = os.path.dirname(os.path.abspath(self.undoFilename)) + '/local.singlefish'
        singlefishf = open(self.singlefishfilename, 'w')
        for s in self.singlefishlist:
            singlefishf.write( '%d %d\n'%(s['off1'], s['off2']) )
        singlefishf.close()
        
    def formatSVM2Plot(self):
        
        self.Tam0 = self.SVM[0].size
        self.Tam1 = self.SVM[1].size
        
        self.SVM2Plot = []
        self.SVM2Plot.append( self.SVM[0].repeat(3) )
        self.SVM2Plot.append( self.SVM[1].repeat(3) )
        
        Min = -0.1
        Max = max( np.diff(self.TS[0]).max(), np.diff(self.TS[1]).max() )
        self.SVMY0 = np.array( self.Tam0 * [Min,Max,Min] )
        self.SVMY1 = np.array( self.Tam1 * [Min,Max,Min] )
        
        
    
    def formatModified2Plot(self):
        self.Tam0 = self.Modified[0].size
        self.Tam1 = self.Modified[1].size
        
        self.Modified2Plot0 = self.Modified[0].repeat(3) 
        self.Modified2Plot1 = self.Modified[1].repeat(3) 
        
        Min = -0.1
        Max = max( np.diff(self.TS[0]).max(), np.diff(self.TS[1]).max() )
        self.ModifiedY0 = np.array( self.Tam0 * [Min,Max,Min] )
        self.ModifiedY1 = np.array( self.Tam1 * [Min,Max,Min] )

    def replotData(self):
        
        Xlimits = self.ax.get_xlim()
        Ylimits = self.ax.get_ylim()
        
        self.removeIPIplots()
        self.fig.canvas.draw()
        
        self.removeWaveplots()
        self.sigfig.canvas.draw()        
        
        self.plotData(Xlimits[0],Xlimits[1], plotSVM=True)
        self.ax.set_ylim(Ylimits)
        self.fig.canvas.draw_idle()
        
        

    def onResize(self,event):
        self.ui.formLayoutWidget.setGeometry(0,0,self.size().width(),self.size().height())

    def createSigFig(self):
        NColumns = self.ui.graphwave.canvas.NColumns

        for i in xrange(NChan):
            self.sigaxes[i].xaxis.set_major_formatter(self.formatterX)
            self.sigaxes[i].set_ylabel(u'$A_{%s}$ (V)'%i)
            self.sigaxes[i].xaxis.set_major_locator(plt.LinearLocator(numticks=5))
            self.sigaxes[i].yaxis.set_major_locator(plt.LinearLocator(numticks=3))
            self.sigaxes[i].grid()
            self.sigaxes[i].plot( [], [], 'k-', lw=1)
        for ax in self.sigaxes[:-NColumns]:
            plt.setp(ax.get_xticklabels(), visible=False)
            plt.setp(ax.xaxis.get_offset_text(), visible=False)

        self.lines = []
        self.auxLines = []

    def plotSigData(self, spksurroudings=DEFAULTSUR):
        if self.selectedIPI == None:
            return
        while len(self.lines) != 0:
            self.lines.pop().remove()
        while len(self.auxLines) != 0:
            self.auxLines.pop().remove()

        loadsurr = 10*spksurroudings
         
        centralts, color = self.selectedIPI
        try:
            nextP1 = next(n for n,spk in enumerate(self.TS[0]) if spk >= centralts)
        except StopIteration:
            nextP1 = self.TS[0].size-1
        surrP1 = self.TS[0][max(0,nextP1-25):min(nextP1+25,self.TS[0].size-1)]
        
        try:
            nextP2 = next(n for n,spk in enumerate(self.TS[1]) if spk >= centralts)
        except StopIteration:
            nextP2 = self.TS[1].size-1
        surrP2 = self.TS[1][max(0,nextP2-25):min(nextP2+25,self.TS[1].size-1)]

        samples = max(0,int(round(centralts * freq)) - loadsurr/2) # The timestamp is on the zero crossing
        f = self.datafile
        f.seek(int(round(samples*NChan*4)))
        data = np.frombuffer(f.read(4*loadsurr*NChan), dtype=np.float32)
        nsamples = data.size // NChan

        t = np.arange(samples, samples+nsamples) / freq
        tmin = centralts - (spksurroudings/freq)
        tmax = centralts + (spksurroudings/freq)

        for i in xrange(NChan):
            ax = self.sigaxes[i]
            ax.get_lines()[0].set_xdata(t)
            ax.get_lines()[0].set_ydata(data[i::NChan])

            ymin = data[i::NChan].min()
            ymax = data[i::NChan].max()
            yabs = max( abs(ymax), abs(ymin) )
            ymax = yabs
            ymin = -yabs

            ax.set_ylim( (ymin, ymax) ) # Auto scale
            ax.set_xlim( (tmin,tmax) )
            #ax.set_ylim( (-ylim, ylim) )# Remove auto scale
            for ts in surrP1:
                self.lines.append(ax.axvline(ts, color='b',lw=2,alpha=0.4, picker=4))
            for ts in surrP2:
                self.lines.append(ax.axvline(ts, color='r',lw=2,alpha=0.4, picker=4))
            self.lines.append(ax.axvline(centralts,color=color,lw=2,alpha=1))
        
        self.sigfig.canvas.draw_idle()
    
    def removeWaveplots(self):
        while len(self.lines) != 0:
            self.lines.pop().remove()
        for i in xrange(NChan):
            self.sigaxes[i].clear()
        self.createSigFig()
    
    def removeIPIplots(self):
        # Remove SVM Lines
        try:
            self.SVMplotB.remove()
        except:
            pass
        try:
            self.SVMplotR.remove()
        except:
            pass
        
        # Remove IPI Lines
        try:
            self.IPIplotB.pop(0).remove()
        except:
            pass
        try:
            self.IPIplotR.pop(0).remove()
        except:
            pass
            
        # Remove IPI scatter dots
        try:
            self.scatter1d.remove()
        except:
            pass
        try:
            self.scatter2d.remove()
        except:
            pass
        try:
            self.scatter1r.remove()
        except:
            pass
        try:
            self.scatter2r.remove()
        except:
            pass
        try:
            self.scatter1s.remove()
        except:
            pass
        try:
            self.scatter2s.remove()
        except:
            pass
        
        # Remove IPI dots
        try:
            self.plot1.pop(0).remove()
        except:
            pass
        try:
            self.plot2.pop(0).remove()
        except:
            pass
       
        # Remove strong SVM pair line
        try:
            self.pltsvmstrongR.pop(0).remove()
        except:
            pass
        try:
            self.pltsvmstrongB.pop(0).remove()
        except:
            pass

    def plotData(self, minX, maxX, plotSVM = True):

        L = maxX - minX
        MIN = minX
        MAX = maxX

        try:
            minIdxX1 = next( n for n,i in enumerate(self.TS[0]) if i > MIN )
        except StopIteration:
            minIdxX1 = self.TS[0].size-1
        try:
            minIdxX2 = next( n for n,i in enumerate(self.TS[1]) if i > MIN )
        except StopIteration:
            minIdxX2 = self.TS[1].size-1

        try:
            maxIdxX1 = next( n for n,i in enumerate(self.TS[0]) if i > MAX)
        except StopIteration:
            maxIdxX1 = self.TS[0].size-1
        try:
            maxIdxX2 = next( n for n,i in enumerate(self.TS[1]) if i > MAX)+1
        except StopIteration:
            maxIdxX2 = self.TS[1].size-1
            
        # Only plot once
        if plotSVM == True:
            try:
                self.SVMplotB.pop(0).remove()
            except:
                pass
            
            try:
                self.SVMplotR.pop(0).remove()
            except:
                pass

            try:
                self.ModifiedplotB.pop(0).remove()
            except:
                pass
            
            try:
                self.ModifiedplotR.pop(0).remove()
            except:
                pass
            
            try:
                self.IPIplotB.pop(0).remove()
            except:
                pass
            
            try:
                self.IPIplotR.pop(0).remove()
            except:
                pass
            
            # Plot SVM Lines
            #self.SVMplotB = self.ax.plot(self.SVM2Plot[0], self.SVMY0, 'b-.', alpha=0.3, lw=2)
            #self.SVMplotR = self.ax.plot(self.SVM2Plot[1], self.SVMY1, 'r-.', alpha=0.3, lw=2)
            
            # Plot Modified Lines
            self.ModifiedplotB = self.ax.plot(self.Modified2Plot0, self.ModifiedY0, 'c--', alpha=0.3, lw=2)
            self.ModifiedplotR = self.ax.plot(self.Modified2Plot1, self.ModifiedY1, 'm--', alpha=0.3, lw=2)

            
        try:
            self.scatter1d.remove()
        except:
            pass
        try:
            self.scatter2d.remove()
        except:
            pass
        try:
            self.scatter1r.remove()
        except:
            pass
        try:
            self.scatter2r.remove()
        except:
            pass
        try:
            self.scatter1s.remove()
        except:
            pass
        try:
            self.scatter2s.remove()
        except:
            pass
        try:
            self.plot1.pop(0).remove()
        except:
            pass
        try:
            self.plot2.pop(0).remove()
        except:
            pass

        # Color proportional to probability only if window is lesser than 30s
        if L<=30 and self.scatterFlag == True:
            self.isScatter = True

            P0 = [i for i,j in self.probs[0][minIdxX1:maxIdxX1]]
            P1 = [j for i,j in self.probs[1][minIdxX2:maxIdxX2]]

            color1 = [ num2color(int(255*i),'b') for i in P0[1:] ]
            color2 = [ num2color(int(255*i),'r') for i in P1[1:] ]

            size1 = 1*np.array([ min(self.dists[0][i]) for i in xrange(minIdxX1,maxIdxX1-1) ])
            size2 = 1*np.array([ min(self.dists[1][i]) for i in xrange(minIdxX2,maxIdxX2-1) ])

            directIdx1 = find(self.direction[0][minIdxX1:maxIdxX1][1:] > 0)
            directIdx2 = find(self.direction[1][minIdxX2:maxIdxX2][1:] > 0)
            
            self.scatter1d = self.ax.scatter(self.TS[0][minIdxX1:maxIdxX1][1:][directIdx1], np.diff(self.TS[0][minIdxX1:maxIdxX1])[directIdx1], c=color1, marker='>', linewidths=0, s=50+np.pi*size1, picker=3, zorder=IPIDATABLUE)
            self.scatter2d = self.ax.scatter(self.TS[1][minIdxX2:maxIdxX2][1:][directIdx2], np.diff(self.TS[1][minIdxX2:maxIdxX2])[directIdx2], c=color2, marker='>', linewidths=0, s=50+np.pi*size2, picker=3, zorder=IPIDATARED)

            reverseIdx1 = find(self.direction[0][minIdxX1:maxIdxX1][1:] < 0)
            reverseIdx2 = find(self.direction[1][minIdxX2:maxIdxX2][1:] < 0)

            self.scatter1r = self.ax.scatter(self.TS[0][minIdxX1:maxIdxX1][1:][reverseIdx1], np.diff(self.TS[0][minIdxX1:maxIdxX1])[reverseIdx1], c=color1, marker='<', linewidths=0, s=50+np.pi*size1, picker=3, zorder=IPIDATABLUE)
            self.scatter2r = self.ax.scatter(self.TS[1][minIdxX2:maxIdxX2][1:][reverseIdx2], np.diff(self.TS[1][minIdxX2:maxIdxX2])[reverseIdx2], c=color2, marker='<', linewidths=0, s=50+np.pi*size2, picker=3, zorder=IPIDATARED)

            svmIdx1 = find(self.direction[0][minIdxX1:maxIdxX1][1:] == 0)
            svmIdx2 = find(self.direction[1][minIdxX2:maxIdxX2][1:] == 0)

            self.scatter1s = self.ax.scatter(self.TS[0][minIdxX1:maxIdxX1][1:][svmIdx1], np.diff(self.TS[0][minIdxX1:maxIdxX1])[svmIdx1], c=color1, marker='o', linewidths=0, s=20+np.pi*size1, picker=3, zorder=IPIDATABLUE)
            self.scatter2s = self.ax.scatter(self.TS[1][minIdxX2:maxIdxX2][1:][svmIdx2], np.diff(self.TS[1][minIdxX2:maxIdxX2])[svmIdx2], c=color2, marker='o', linewidths=0, s=20+np.pi*size2, picker=3, zorder=IPIDATARED)

        else:
            self.isScatter = False

            # Lines and dots are plotter separately for picker act only on dots
            self.IPIplotR = self.ax.plot(self.TS[1][1:], np.diff(self.TS[1]), 'r-', lw=1)
            self.IPIplotB = self.ax.plot(self.TS[0][1:], np.diff(self.TS[0]), 'b-', lw=1)

            self.plot1 = self.ax.plot(self.TS[0][minIdxX1:maxIdxX1][1:], np.diff(self.TS[0][minIdxX1:maxIdxX1]), 'b.', mew=2, picker=5, zorder=IPIDATABLUE)
            self.plot2 = self.ax.plot(self.TS[1][minIdxX2:maxIdxX2][1:], np.diff(self.TS[1][minIdxX2:maxIdxX2]), 'r.', mew=2, picker=5, zorder=IPIDATARED)

        self.adjustAxes(minX, maxX)

    def adjustAxes(self, minX, maxX):
        self.ax.set_title('IPIs and SVM classification')
        self.ax.xaxis.set_major_formatter(self.formatterX)
        self.ax.yaxis.set_major_formatter(self.formatterY)

        self.Mean = ( np.diff(self.TS[0]).mean() + np.diff(self.TS[1]).mean() ) / 2.
        YMIN = 0.
        YMAX = 2.5 * self.Mean

        self.ax.axis([minX, maxX, YMIN, YMAX])

    def sec2hms(self, x, pos):
        t = int(round(1e4*x))
        s, ms = divmod(t, 1e4)
        m, s = divmod(x, 60)
        h, m = divmod(m, 60)
        return '%02d:%02d:%02d.%04d' % (h, m, s, ms)

    def sec2msus(self,x,pos):
        ms = int(1e3*x)
        us = int(((1e3*x)%1)*1e3)
        return '%03d.%03d' % (ms,us)


if __name__ == '__main__':
    description = 'Browse the IPI of the generated time series and provides tools for manual correction'
    parser = MyParser(description=description, formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument('db_file', type=str, help='Databank generated file')
    parser.add_argument('timeseries_file', type=argparse.FileType('r'+openmode), help='Location of the timeseries (I32) file')
    parser.add_argument('ipi_file', type=str, help='Location of the file with the timestamps, in the case of the DB is modified')
    parser.add_argument('--saturation', type=str, help='low,high saturation level')
    parser.add_argument('--stepSize', type=float, default=60., help='Step size for moving on the IPI time series. Default = 90s')
    parser.add_argument('--winSize', type=float, default=90., help='Window size for plotting the IPI time series. Default = 120s')

    args = parser.parse_args()
    dbf = args.db_file
    datafile = args.timeseries_file
    ipifilename = args.ipi_file
    saturation = args.saturation
    if saturation is not None:
        lowsaturation = float(saturation.split(',')[0].strip())
        highsaturation = float(saturation.split(',')[1].strip())
    else:
        lowsaturation = lowSat
        highsaturation = highSat
    stepSize = args.stepSize
    winSize = args.winSize
    
    if os.path.isfile(dbf) == False:
        sys.stdout.write('DB file not found\n')
        sys.stdout.flush()
        
    # Create folder to save DB modifications
    # /home/datafile.memmapf32 -> datafilename == datafile
    # Pattern:
    # datafilename/
    #           DBname_undo.keys
    #           key1.undo
    #           key2.undo
    #           key3.undo
    #           ...
    datafilename = datafile.name.split('/')[-1].split('.')[0]
    dbfiledir = os.path.dirname(os.path.abspath(dbf))
    dbname = dbfiledir + '/' + dbf.split('/')[-1].split('.')[0] + '_undo.keys'
    if os.path.isdir(dbfiledir + '/' + datafilename) == False:
        os.makedirs(dbfiledir + '/' + datafilename)
    datafilename = os.path.abspath(dbfiledir + '/' + datafilename)
    
    undoFilename = dbfiledir + '/' + datafilename + '/' + dbname
    
    # Create undo file if it does not exists (a for append -> do not erase any data)
    undoFilename = '/tmp/teste.undo'
    open(undoFilename,'a').close()

    app = QtWidgets.QApplication(sys.argv)

    sys.stdout.write(datafilename)
    sys.stdout.flush()
    myapp = PlotData(app, dbf, datafile, undoFilename, datafilename, ipifilename, (lowsaturation, highsaturation), winSize, stepSize)

    Pick = PickPoints(myapp, ipifilename)

    myapp.show()
    sys.exit(app.exec_())
