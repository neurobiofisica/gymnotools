#!/usr/bin/env python
# -*- coding: utf-8 -*-

import pymp
import numpy as np
import recogdb
import struct
import scipy.signal

import sys,os
import argparse

from windowfile import winFile

sys.path.append( os.path.abspath('..') )
from read_param import *
# import NChan, freq, winSize

complete = False
NChanloc = 4
hmin = 0.05

jump = True
#startOn = int(40*freq)
startOn = 136006964
onDirection = 1

if sys.version_info.major == 3:
    xrange = range
    mode = 'b'
else:
    mode = ''

overlapRange = int(0.003*freq)

class MyParser(argparse.ArgumentParser):
    def error(self, message):
        self.print_help()
        sys.stderr.write('\nerror: %s\n'%message)
        sys.exit(2)




class recog:
    def __init__(self):
        self.direction = None

        self. off = None
        self.samples = None
        self.center = None
        #self.svmcause, self.svmpair, self.probA, self.probB = (None, None, None, None)
        self.svmcause, self.probA, self.probB = (None, None, None)
        self.pair = np.zeros(2, dtype=np.int64)

        self.templateA = None
        self.templateB = None
        self.lastCenterA = None
        self.lastCenterB = None

        self.lastTSA = None
        self.lastTSB = None
        self.lastIPIA = None
        self.lastIPIB = None

    def init_iterate(self, db, wins, svmpairs, svmpairsTam, probs, tsoutput):
        self.db = db
        self.wins = wins
        self.svmpairs = svmpairs
        self.svmpairsTam = svmpairsTam
        self.probs = probs
        self.tsoutput = tsoutput

    def init_export(self, db, tsoutput):
        self.db = db
        self.tsoutput = tsoutput

    def emitSingleA(self, sigs):
        self.templateA = sigs.copy() ###### Necessario? Nao irei alterar a variavel, apenas substitui-la
        self.templateAsize = self.samples
        self.lastCenterA = self.center
        
        if recogdb.verifyKey(self.db, self.off) is None:
            recogdb.writeEntry(self.db, self.off, 1, 0, 0, 1<<30, 1<<30, 0, self.off+self.center, -1, self.svmcause, -1, self.probA, self.probB, list(sigs.values()))
        else:
            sys.stdout.write('SVM already in DB\n')
        if jump:
            if self.off >= startOn and self.direction == onDirection: #################################
                self.tsoutput.write('1 %d\n'%(self.off+self.center))
        else:
            self.tsoutput.write('1 %d\n'%(self.off+self.center))

        if self.lastTSA is None:
            self.lastTSA = self.off+self.center
        else:
            self.lastIPIA = self.off+self.center - self.lastTSA
            self.lastTSA = self.off+self.center

    def emitSingleB(self,sigs):
        self.templateB = sigs.copy()
        self.templateBsize = self.samples
        self.lastCenterB = self.center

        if recogdb.verifyKey(self.db, self.off) is None:
            recogdb.writeEntry(self.db, self.off, 2, 0, 1<<30, 0, 1<<30, 0, -1, self.off+self.center, self.svmcause, -1, self.probA, self.probB, list(sigs.values()))
        else:
            sys.stdout.write('SVM already in DB\n')
        if jump:
            if self.off >= startOn and self.direction == onDirection: #################################
                self.tsoutput.write('-1 %d\n'%(self.off+self.center))
        else:
            self.tsoutput.write('-1 %d\n'%(self.off+self.center))

        if self.lastTSB is None:
            self.lastTSB = self.off+self.center
        else:
            self.lastIPIB = self.off+self.center - self.lastTSB
            self.lastTSB = self.off+self.center

    def predict_overlap(self, direction):
        if direction >= 0:
            cond1 = (self.off+self.center > self.lastTSB + self.lastIPIB - overlapRange)
            cond2 = (self.off+self.center < self.lastTSB + self.lastIPIB + overlapRange)
        else:
            # lastIPIB is negative in this situation
            cond1 = (self.off+self.center > self.lastTSB + self.lastIPIB - overlapRange)
            cond2 = (self.off+self.center < self.lastTSB + self.lastIPIB + overlapRange)
            

    def iterate(self, direction, cont=False):
        self.direction = direction
        if direction >= 0:
            winfunc = self.wins.nextWin
            singlefishIdx = 0
            adder = +1
        else:
            self.wins.end()
            winfunc = self.wins.prevWin
        singlefishIdx = 0
        adder = +1

        ret = not None
        while (ret is not None):
            self.tsoutput.flush()

            ret = winfunc()
            if ret is not None:
                lastLen, self.off, self.samples, channels, self.center, sigs = ret
                #self.svmcause, self.svmpair, self.probA, self.probB = self.probs[self.off]
                self.svmcause, self.probA, self.probB = self.probs[self.off]
            else:
                print('Spikes file ended')
                continue

            if direction == 1:
                perc = 100.*self.off / (1.*self.svmpairs[-1,1])
            else:
                perc = -100.*(self.off-self.svmpairs[0,1]) / (1.*self.svmpairs[0,1])

            if singlefishIdx < svmpairsTam:
                self.pair[:] = svmpairs[singlefishIdx,:]

            if cont == True:
                if recogdb.verifyKey(self.db, self.off) is not None:
                    if self.off == self.pair[1]:
                        singlefishIdx += adder
                    print(self.off)
                    continue

            #print(self.off)

            if self.off == self.pair[1]:


                if self.pair[0] == 1:
                    if self.lastTSB is not None and self.lastIPIB is not None:
                        if (self.off+self.center > self.lastTSB + self.lastIPIB - overlapRange) and (self.off+self.center < self.lastTSB + self.lastIPIB + overlapRange):
                            if (self.templateA is not None) and (self.templateB is not None):
                                sys.stdout.write('%d\t%.03f%%\tOverlap A predicted'%(self.off, perc))
                                sys.stdout.flush()
                                self.continuity(sigs, predicted=True)

                        else:

                            print('%d\t%.03f%%\tEmmiting single A\t%.02f%%\t\tA'%(self.off, perc, 100*self.probA))
                            self.emitSingleA(sigs)
                    else:

                        print('%d\t%.03f%%\tEmmiting single A\t%.02f%%\t\tA'%(self.off, perc, 100*self.probA))
                        self.emitSingleA(sigs)

                    singlefishIdx += adder
                else:
                    if self.lastTSA is not None and self.lastIPIA is not None:
                        if (self.off+self.center > self.lastTSA + self.lastIPIA - overlapRange) and (self.off+self.center < self.lastTSA + self.lastIPIA + overlapRange):
                            if (self.templateA is not None) and (self.templateB is not None):
                                sys.stdout.write('%d\t%.03f%%\tOverlap B predicted'%(self.off, perc))
                                sys.stdout.flush()
                                self.continuity(sigs, predicted=True)
                        else:

                            print('%d\t%.03f%%\tEmmiting single B\t%.02f%%\t\tB'%(self.off, perc, 100*self.probB))
                            self.emitSingleB(sigs)
                    else:

                        print('%d\t%.03f%%\tEmmiting single B\t%.02f%%\t\tB'%(self.off, perc, 100*self.probB))
                        self.emitSingleB(sigs)
                    singlefishIdx += adder
            else:
                if (self.templateA is None) or (self.templateB is None):
                    print('%d\t%.03f%%\tLooking for first SVM\t%d\t%d'%(self.off, perc, self.pair[1], singlefishIdx))
                    continue
                sys.stdout.write('%d\t%.03f%%\tCalling continuity'%(self.off, perc))
                sys.stdout.flush()
                self.continuity(sigs)

    def continuity(self, sigs, predicted=False):

        #if self.off < 3280000:
        #    return

        useChans = np.zeros(NChanloc, dtype=np.int)
        maxes = np.zeros(NChan)
        # Use only the NChanloc channels with highest amplitude
        for n, sig in sigs.items():
            maxes[n] = np.abs(sig).max()
        for n in range(NChanloc):
            useChans[n] = maxes.argmax()
            maxes[ useChans[n] ] = -1            


        if jump:
            if self.off < startOn and self.direction == onDirection: #################################
                return

        h = H[self.off:self.off+sigs[0].size]


        if self.off == -123456789:
            import matplotlib.pyplot as plt
            plt.plot(h,'b-')
            plt.plot(sigs[0])
        # Remove extremities
        if True:
            try:
                rem = next(n for n,i in enumerate(sigs[0]) if i != 0)
            except StopIteration:
                rem = 0
            try:
                reme = h.size-next(n for n,i in enumerate(sigs[0][::-1]) if i != 0)
            except StopIteration:
                reme = h.size
            h = h[rem:reme]
        else:
            rem = 0
        if self.off == -123456789:
            print('\n\n%d %d'%(rem, reme))
            import matplotlib.pyplot as plt
            plt.plot(np.arange(rem,reme), h,'g-')
            plt.show()
        locs_raw = scipy.signal.argrelmax(h,order=15)
        locs = np.unique(locs_raw)
        locs = locs[ np.where(h[locs] > hmin) ]
        locs += rem

        #locs = np.unique(locs)
        if len(locs) > 2:
            doublet = True
            v1 = -1
            m1 = -1
            v2 = -1
            m2 = -1
            for l in locs:
                if h[l-rem] > v1:
                    m1 = l
                    v1 = h[l-rem]
            for l in locs:
                if h[l-rem] > v2 and h[l-rem] < v1 and abs(l - m1) > 15:
                    m2 = l
                    v2 = h[l-rem]
        elif len(locs) == 2:
            doublet = True
            m1 = locs[0]
            m2 = locs[1]
        elif len(locs) == 1:
            doublet = False # It can still be a doublet!
            m1 = locs[0]
            m2 = locs[0]
        else:
            doublet = False
            m1 = sigs[0].size//2
            m2 = sigs[0].size//2
            '''import matplotlib.pyplot as plt
            for n in range(NChan):
                plt.plot(sigs[n], 'C0-')
            plt.plot(np.arange(rem,rem+h.size),h,'C2-')
            plt.title(self.off)
            plt.show()
            sys.exit(-1)'''

        if self.off == -123456789:
            print('\n\n')
            print(locs)
            print('%d %d'%(m1,m2))
            print('777777777777777777777 - %d %d'%(self.templateAsize, self.templateBsize))
            import matplotlib.pyplot as plt
            plt.figure(1)
            for n in range(NChan):
                plt.plot(sigs[n], 'C0-')
            plt.plot(np.arange(rem,rem+h.size),h,'C2-')
            plt.plot( (m1, m1), (0,2), 'k-')
            plt.plot( (m2, m2), (0,2), 'k-')
            plt.title(self.off)
            plt.show()

        tamA = self.templateAsize
        tamB = self.templateBsize


        zfill = 128
        tamTotal = sigs[0].size + 2*zfill
        bA = 0
        eA = tamTotal - bA - tamA
        bB = 0
        eB = tamTotal - bB - tamB
        data = np.array([], dtype=np.float32)
        tempA = np.array([], dtype=np.float32)
        tempB = np.array([], dtype=np.float32)
        for ch, s in sigs.items():

            if ch not in useChans:
                continue

            data = np.concatenate( (data, np.concatenate( (np.zeros(zfill), s, np.zeros(zfill)) )) )
            tempA = np.concatenate( (tempA, self.templateA[ch], np.zeros(eA)) )
            tempB = np.concatenate( (tempB, self.templateB[ch], np.zeros(eB)) )
        
        tempsA = np.zeros((tamTotal, tempA.size), dtype=np.float32)
        for i in xrange(tamTotal):
            tempsA[i,i:] = tempA[:tempA.size-i]
        tempsB = np.zeros((tamTotal, tempB.size), dtype=np.float32)
        for i in xrange(tamTotal):
            tempsB[i,i:] = tempB[:tempB.size-i]

        if doublet == False:
            if complete == True:
                arounds = winSize
            else:
                arounds = 64
            cPos = m1
            beg = max(0,cPos - arounds)
            end = min(tempsA[:,0].size, cPos + arounds)

            # Minimize A
            sys.stdout.write('A ')
            sys.stdout.flush()
            distAm = np.array( [np.sum(np.absolute(data-tempsA[i,:])) for i in xrange(beg,end)] , dtype=np.float32)
            posA = distAm.argmin()
            distA = distAm[posA]
            posA += beg

            # Minimize B
            sys.stdout.write('B ')
            sys.stdout.flush()
            distBm = np.array( [np.sum(np.absolute(data-tempsB[i,:])) for i in xrange(beg,end)] , dtype=np.float32)
            posB = distBm.argmin()
            distB = distBm[posB]
            posB += beg


            sys.stdout.write('AB ')
            #sys.stdout.write('\n')
            sys.stdout.flush()
            if complete == True:
                distABm = pymp.shared.array( (tamTotal, tamTotal) ,dtype=np.float32)
                distABm.fill(np.inf)
                datap = pymp.shared.array( data.size, dtype=np.float32)
                datap[:] = data[:]
                with pymp.Parallel(8) as p:
                    for i in p.range(beg,end):
                        tA = tempsA[i,:]
                        for j in range(beg,end):
                            distABm[i,j] = np.sum(np.absolute(datap - tA - tempsB[j,:]))
            else:
                distABm = np.empty( (tamTotal, tamTotal), dtype=np.float32)
                distABm.fill(np.inf)
                datap = data
                for i in range(beg,end):
                    tA = tempsA[i,:]
                    for j in range(beg,end):
                        distABm[i,j] = np.sum(np.absolute(datap - tA - tempsB[j,:]))
            
            posA_AB, posB_AB = np.unravel_index(distABm.argmin(), distABm.shape)
            distAB = distABm[posA_AB, posB_AB]

            if self.off == -123456789:
                #print(l)
                import matplotlib.pyplot as plt
                fig = plt.figure(1)
                ax1 = fig.add_subplot(311)
                ax1.set_title(self.off)
                ax1.plot(data, 'k-')
                ax1.plot(tempsA[posA,:], 'b-')
                ax1.plot(np.abs(data - tempsA[posA,:]), 'b-', alpha=0.3)
                ax1.plot( (cPos, cPos), (-1,1), 'k-')
                ax2 = fig.add_subplot(312, sharex=ax1)
                ax2.plot(data, 'k-')
                ax2.plot(tempsB[posB,:], 'r-')
                ax2.plot(np.abs(data - tempsB[posB,:]), 'r-', alpha=0.3)
                ax2.plot( (cPos, cPos), (-1,1), 'k-')
                ax3 = fig.add_subplot(313, sharex=ax1)
                ax3.plot(data, 'k-')
                ax3.plot(tempsA[posA_AB,:], 'b-')
                ax3.plot(tempsB[posB_AB,:], 'r-')
                ax3.plot(np.abs(data - tempsA[posA_AB,:] - tempsB[posB_AB,:]), 'g-',alpha=0.3)
                ax3.plot( (cPos, cPos), (-1,1), 'k-')
                plt.show()
        else:
            l1 = min(m1,m2)
            l2 = max(m1,m2)

            if self.off == -123456789:
                import matplotlib.pyplot as plt
                fig = plt.figure(3)
                ax1 = fig.add_subplot(311)
                ax1.plot(data)
                ax2 = fig.add_subplot(312,sharex=ax1)
                ax2.plot(tempsA[l1,:])
                ax3 = fig.add_subplot(313, sharex=ax1)
                ax3.plot(tempsA[l2,:])

            if complete == True:
                aroundd = winSize
            else:
                aroundd = 40
            beg1d = max(0,l1 - aroundd)
            end1d = min(l1 + aroundd, self.samples+2*zfill - tamA)
            beg2d = max(0,l2 - aroundd)
            end2d = min(l2 + aroundd, self.samples+2*zfill - tamA)

            if beg2d < end1d:
                doOnce = True
                begd = beg1d
                endd = end2d
            else:
                doOnce = False


            if doOnce == False:
                '''if self.off == -123456789:
                    import matplotlib.pyplot as plt
                    print('############ %d %d %d'%(beg1d, beg2d, zfill))
                    print('############ %d %d'%(l1, l2))
                    beg1d = 0
                    beg2d = 0
                    end1d = self.samples+2*zfill - tamA
                    end2d = self.samples+2*zfill - tamA
                    plt.figure(30)
                    plt.subplot(311)
                    plt.plot(data,'k-')
                    plt.subplot(312)
                    plt.plot(tempsA[0,:],'b-')
                    plt.subplot(313)
                    plt.plot(tempsB[0,:],'r-')
                    plt.figure(10)
                    plt.subplot(411)
                    plt.plot(np.arange(beg1d,end1d), np.array( [np.sum(np.absolute(data - tempsA[i,:])) for i in xrange(beg1d,end1d)], dtype=np.float32))
                    plt.subplot(412)
                    plt.plot(np.arange(beg2d,end2d), np.array( [np.sum(np.absolute(data - tempsA[i,:])) for i in xrange(beg2d,end2d)], dtype=np.float32))
                    plt.subplot(413)
                    plt.plot(np.arange(beg1d,end1d), np.array( [np.sum(np.absolute(data - tempsB[i,:])) for i in xrange(beg1d,end1d)], dtype=np.float32))
                    plt.subplot(414)
                    plt.plot(np.arange(beg2d,end2d), np.array( [np.sum(np.absolute(data - tempsB[i,:])) for i in xrange(beg2d,end2d)], dtype=np.float32))
                    plt.figure(20)
                    distABm = np.empty( (self.samples+2*zfill - tamA, self.samples+2*zfill - tamB) ,dtype=np.float32)
                    distABm.fill(np.inf)
                    for i in xrange(0,distABm.shape[0]):
                        tA = tempsA[i,:]
                        for j in xrange(0,distABm.shape[1]):
                            distABm[i,j] = np.sum(np.absolute(data - tA - tempsB[j,:]))
                    plt.pcolormesh(distABm)
                    plt.colorbar()
                    plt.show()'''


                distA1 = np.array( [np.sum(np.absolute(data - tempsA[i,:])) for i in xrange(beg1d,end1d)], dtype=np.float32)
                posA1 = distA1.argmin()
                distA1 = distA1[posA1]
                posA1 += beg1d
                distA2 = np.array( [np.sum(np.absolute(data - tempsA[i,:])) for i in xrange(beg2d,end2d)], dtype=np.float32)
                posA2 = distA2.argmin()
                distA2 = distA2[posA2]
                posA2 += beg2d
                sys.stdout.write('A ')

                distB1 = np.array( [np.sum(np.absolute(data - tempsB[i,:])) for i in xrange(beg1d,end1d)], dtype=np.float32)
                posB1 = distB1.argmin()
                distB1 = distB1[posB1]
                posB1 += beg1d
                distB2 = np.array( [np.sum(np.absolute(data - tempsB[i,:])) for i in xrange(beg2d,end2d)], dtype=np.float32)
                posB2 = distB2.argmin()
                distB2 = distB2[posB2]
                posB2 += beg2d
                sys.stdout.write('B ')
                sys.stdout.write('   ')



                if complete == True:
                    distABm = pymp.shared.array( (tamTotal, tamTotal) ,dtype=np.float32)
                    distABm.fill(np.inf)
                    distBAm = pymp.shared.array( (tamTotal, tamTotal) ,dtype=np.float32)
                    distBAm.fill(np.inf)
                    datap = pymp.shared.array( data.size, dtype=np.float32)
                    datap[:] = data[:]
                    with pymp.Parallel(8) as p:
                        for i in p.range(beg1d,end1d):
                            tA = tempsA[i,:]
                            for j in xrange(beg2d,end2d):
                                distABm[i,j] = np.sum(np.absolute(datap - tA - tempsB[j,:]))
                else:
                    distABm = np.empty( (self.samples+2*zfill - tamA, self.samples+2*zfill - tamB) ,dtype=np.float32)
                    distABm.fill(np.inf)
                    distBAm = np.empty( (self.samples+2*zfill - tamA, self.samples+2*zfill - tamB) ,dtype=np.float32)
                    distBAm.fill(np.inf)
                    datap = data
                    for i in xrange(beg1d,end1d):
                        tA = tempsA[i,:]
                        for j in xrange(beg2d,end2d):
                            distABm[i,j] = np.sum(np.absolute(datap - tA - tempsB[j,:]))

                posA_AB, posB_AB = np.unravel_index(distABm.argmin(), distABm.shape)
                distAB = distABm[posA_AB, posB_AB]
                if complete == True:
                    with pymp.Parallel(8) as p:
                        for i in p.range(beg2d,end2d):
                            tA = tempsA[i,:]
                            for j in xrange(beg1d,end1d):
                                distBAm[i,j] = np.sum(np.absolute(datap - tA - tempsB[j,:]))
                else:
                    for i in xrange(beg2d,end2d):
                        tA = tempsA[i,:]
                        for j in xrange(beg1d,end1d):
                            distBAm[i,j] = np.sum(np.absolute(datap - tA - tempsB[j,:]))
                posA_BA, posB_BA = np.unravel_index(distBAm.argmin(), distBAm.shape)
                distBA = distBAm[posA_BA, posB_BA]

            else:
                distA1 = np.array( [np.sum(np.absolute(data - tempsA[i,:])) for i in xrange(begd,endd)], dtype=np.float32)
                posA1 = distA1.argmin()
                distA1 = distA1[posA1]
                posA1 += begd
                distA2 = distA1
                posA2 = posA1
                
                distB1 = np.array( [np.sum(np.absolute(data - tempsB[i,:])) for i in xrange(begd,endd)], dtype=np.float32)
                posB1 = distB1.argmin()
                distB1 = distB1[posB1]
                posB1 += begd
                distB2 = distB1
                posB2 = posB1

                distABm = pymp.shared.array( (tamTotal, tamTotal) ,dtype=np.float32)
                distABm.fill(np.inf)
                datap = pymp.shared.array( data.size, dtype=np.float32)
                datap[:] = data[:]

                with pymp.Parallel(8) as p:
                    for i in p.range(begd,endd):
                        tA = tempsA[i,:]
                        for j in range(begd,endd):
                            distABm[i,j] = np.sum(np.absolute(datap - tA - tempsB[j,:]))
                posA_AB, posB_AB = np.unravel_index(distABm.argmin(), distABm.shape)
                distAB = distABm[posA_AB, posB_AB]

                distBA = distAB
                posA_BA = posA_AB
                posB_BA = posB_AB



            l = [distA1, distA2, distB1, distB2, distAB, distBA]
            l2 = [posA1, posA2, posB1, posB2, posA_AB, posB_AB, posA_BA, posB_BA]

            if self.off == -123456789:
                print(l)
                print(l2)
                import matplotlib.pyplot as plt
                fig = plt.figure(1)
                ax1 = fig.add_subplot(611)
                ax1.set_title(self.off)
                ax1.plot(data, 'k-')
                ax1.plot(tempsA[posA1,:], 'b-')
                ax1.plot(np.abs(data - tempsA[posA1,:]), 'b-', alpha=0.3)
                ax2 = fig.add_subplot(612, sharex=ax1)
                ax2.plot(data, 'k-')
                ax2.plot(tempsB[posB2,:], 'r-')
                ax2.plot(np.abs(data - tempsB[posB2,:]), 'r-', alpha=0.3)
                ax3 = fig.add_subplot(613, sharex=ax1)
                ax3.plot(data, 'k-')
                ax3.plot(tempsA[posA_AB,:], 'b-')
                ax3.plot(tempsB[posB_AB,:], 'r-')
                ax3.plot(np.abs(data - tempsA[posA_AB,:] - tempsB[posB_AB,:]), 'g-',alpha=0.3)
                ax4 = fig.add_subplot(614,sharex=ax1)
                ax4.plot(data, 'k-')
                ax4.plot(tempsA[posA2,:], 'b-')
                ax4.plot(np.abs(data - tempsA[posA2,:]), 'b-', alpha=0.3)
                ax5 = fig.add_subplot(615,sharex=ax1)
                ax5.plot(data, 'k-')
                ax5.plot(tempsB[posB1,:], 'r-')
                ax5.plot(np.abs(data - tempsB[posB1,:]), 'r-', alpha=0.3)
                ax6 = fig.add_subplot(616,sharex=ax1)
                ax6.plot(data, 'k-')
                ax6.plot(tempsA[posA_BA,:], 'b-')
                ax6.plot(tempsB[posB_BA,:], 'r-')
                ax6.plot(np.abs(data - tempsA[posA_BA,:] - tempsB[posB_BA,:]), 'g-',alpha=0.3)
                plt.show()
                #sys.exit(-1)

            if np.argmin(l) == 0:
                posA = posA1
                distA = l[0]
                posB = 0
                distB = np.inf
                posA_AB = 0
                posB_AB = 0
                distAB = np.inf
            elif np.argmin(l) == 1:
                posA = posA2
                distA = l[1]
                posB = 0
                distB = np.inf
                posA_AB = 0
                posB_AB = 0
                distAB = np.inf
            elif np.argmin(l) == 2:
                posA = 0
                distA = np.inf
                posB = posB1
                distB = l[2]
                posA_AB = 0
                posB_AB = 0
                distAB = np.inf
            elif np.argmin(l) == 3:
                posA = 0
                distA = np.inf
                posB = posB2
                distB = l[3]
                posA_AB = 0
                posB_AB = 0
                distAB = np.inf
            elif np.argmin(l) == 4:
                posA = 0
                distA = np.inf
                posB = 0
                distB = np.inf
                posA_AB = posA_AB
                posB_AB = posB_AB
                distAB = l[4]
            else:
                posA = 0
                distA = np.inf
                posB = 0
                distB = np.inf
                posA_AB = posA_BA
                posB_AB = posB_BA
                distAB = l[5]

        '''if  self.off==32680:
            import matplotlib.pyplot as plt
            plt.figure(1)
            plt.subplot(211)
            plt.plot(distAm)
            print('')
            print('%f %d'%(distAm.min(), posA))
            plt.subplot(212)
            plt.plot(distBm)
            print('%f %d'%(distBm.min(), posB))
            plt.figure(3)
            plt.imshow(distABm)
            print('%f %d %d'%(distABm.min(), posA_AB, posB_AB))
            plt.colorbar()

            plt.figure(2)
            ax1 = plt.subplot(311)
            plt.plot(tempA)
            np.save('/tmp/tempA.npy',tempA)
            plt.subplot(312,sharey=ax1,sharex=ax1)
            plt.plot(tempB)
            np.save('/tmp/tempB.npy',tempB)
            plt.subplot(313,sharey=ax1,sharex=ax1)
            plt.plot(data)
            np.save('/tmp/data.npy',data)
            plt.show()
            sys.exit(-1)'''


        #sys.stdout.write('distsOk ')
        #sys.stdout.flush()
        if self.off== -123456789:
       # if False:
            sys.stdout.write('\n\n\n')
            sys.stdout.write(repr(posA)+'\n')
            sys.stdout.write(repr(zfill)+'\n')
            sys.stdout.write(repr(self.samples)+'\n')
            sys.stdout.write(repr(tamA)+'\n')
            sys.stdout.flush()
            import matplotlib.pyplot as plt

            plt.figure(1, figsize=(22,16))

            ax1 = plt.subplot2grid((3,4), (0,0),colspan=3)
            if distA < distB and distA < distAB:
                plt.title('A')
            elif distB < distA and distB < distAB:
                plt.title('B')
            elif distAB <= distA and distAB <= distB:
                plt.title('AB')

            plt.plot(data, 'k-', alpha=1.0)
            plt.plot(np.arange(posA, tempA.size-1), tempA[:-posA-1], 'b-', alpha=0.5)
            for i in xrange(11):
                posinicial = i*(self.samples+2*zfill)
                plt.plot([posinicial+posA+self.lastCenterA, posinicial+posA+self.lastCenterA], [-10,10], 'b-', alpha=0.3)

            ax2 = plt.subplot2grid((3,4), (1,0), sharex=ax1, sharey=ax1, colspan=3)
            plt.plot(data, 'k-', alpha=1.0)
            plt.plot(np.arange(posB, tempB.size-1), tempB[:-posB-1], 'r-', alpha=0.5)
            for i in xrange(11):
                posinicial = i*(self.samples+2*zfill)
                plt.plot([posinicial+posB+self.lastCenterB, posinicial+posB+self.lastCenterB], [-10,10], 'r-', alpha=0.3)

            ax3 = plt.subplot2grid((3,4), (2,0), sharex=ax1, sharey=ax1,colspan=3)
            plt.plot(data, 'k-', alpha=1.0)
            plt.plot(np.arange(posA_AB, tempA.size-1), tempA[:-posA_AB-1], 'b-', alpha=0.5)
            plt.plot(np.arange(posB_AB, tempB.size-1), tempB[:-posB_AB-1], 'r-', alpha=0.5)
            for i in xrange(11):
                posinicial = i*(self.samples+2*zfill)
                plt.plot([posinicial+posA_AB+self.lastCenterA, posinicial+posA_AB+self.lastCenterA], [-10,10], 'b-', alpha=0.3)
                plt.plot([posinicial+posB_AB+self.lastCenterB, posinicial+posB_AB+self.lastCenterB], [-10,10], 'r-', alpha=0.3)

            '''ax4 = plt.subplot2grid((3,4), (0,3))
            plt.plot(distAm)

            ax5 = plt.subplot2grid((3,4), (1,3))
            plt.plot(distBm)

            ax6 = plt.subplot2grid((3,4), (2,3))
            plt.pcolormesh(distABm)
            plt.axis('tight')
            plt.colorbar()'''

            plt.show()
            #sys.exit(-1)
        #posA = posA + self.lastCenterA - zfill
        #posB = posB + self.lastCenterB - zfill

        ###########################################
        ############### Verificar se existe no db #
        ###########################################
        tup = recogdb.readHeaderEntry(self.db,self.off)
        if tup is not None:
            off, data, spkwin = tup

            mindist = min(distA, distB, distAB)
            dbdistA = data[ recogdb.dicFields['distA'] ]
            dbdistB = data[ recogdb.dicFields['distB'] ]
            dbdistAB = data[ recogdb.dicFields['distAB'] ]
            mindistDB = min(dbdistA, dbdistB, dbdistAB)
            if predicted == True and data[ recogdb.dicFields['svm'] ] == 's':
                mindist = np.inf
            if mindistDB < mindist:
                #sys.stdout.write('Leaving DB as is')
                sys.stdout.write('L\n')

                # Update lastTS and lastIPI with DB data
                idx = np.argmin( (dbdistA, dbdistB, dbdistAB) )
                if idx == 0:
                    if self.lastTSA is None:
                        self.lastTSA = data[ recogdb.dicFields['correctedPosA'] ]
                    else:
                        lastTSA_new = data[ recogdb.dicFields['correctedPosA'] ]
                        self.lastIPIA = lastTSA_new - self.lastTSA
                        self.lastTSA = lastTSA_new
                elif idx == 1:
                    if self.lastTSB is None:
                        self.lastTSB = data[ recogdb.dicFields['correctedPosB'] ]
                    else:
                        lastTSB_new = data[ recogdb.dicFields['correctedPosB'] ]
                        self.lastIPIB = lastTSB_new - self.lastTSB
                        self.lastTSB = lastTSB_new
                else:
                    if self.lastTSA is None:
                        self.lastTSA = data[ recogdb.dicFields['correctedPosA'] ]
                    else:
                        lastTSA_new = data[ recogdb.dicFields['correctedPosA'] ]
                        self.lastIPIA = lastTSA_new - self.lastTSA
                        self.lastTSA = lastTSA_new
                    if self.lastTSB is None:
                        self.lastTSB = data[ recogdb.dicFields['correctedPosB'] ]
                    else:
                        lastTSB_new = data[ recogdb.dicFields['correctedPosB'] ]
                        self.lastIPIB = lastTSB_new - self.lastTSB
                        self.lastTSB = lastTSB_new

                return None

        if distA < distB and distA < distAB:
            if jump:
                if self.off >= startOn and self.direction == onDirection: #################################
                    recogdb.writeEntry(self.db, self.off, 1, self.direction, distA, distB, distAB, 0, self.off+posA, -1, self.svmcause, -1, self.probA, self.probB, list(sigs.values()))
                    self.tsoutput.write('1 %d\n'%(self.off+posA))
            else:
                recogdb.writeEntry(self.db, self.off, 1, self.direction, distA, distB, distAB, 0, self.off+posA, -1, self.svmcause, -1, self.probA, self.probB, list(sigs.values()))
                self.tsoutput.write('1 %d\n'%(self.off+posA))
            sys.stdout.write('\tsingle\tA')
            sys.stdout.flush()

            # Replace template
            if self.samples == winSize:
                self.templateA = sigs.copy()
                self.templateAsize = winSize
            self.lastCenterA = posA

            if self.lastTSA is None:
                self.lastTSA = self.off+posA
            else:
                self.lastIPIA = self.off+posA - self.lastTSA
                self.lastTSA = self.off+posA

        elif distB < distA and distB < distAB:
            if jump:
                if self.off >= startOn and self.direction == onDirection: #################################
                    recogdb.writeEntry(self.db, self.off, 2, self.direction, distA, distB, distAB, 0, -1, self.off+posB, self.svmcause, -1, self.probA, self.probB, list(sigs.values()))
                    self.tsoutput.write('-1 %d\n'%(self.off+posB))
            else:
                recogdb.writeEntry(self.db, self.off, 2, self.direction, distA, distB, distAB, 0, -1, self.off+posB, self.svmcause, -1, self.probA, self.probB, list(sigs.values()))
                self.tsoutput.write('-1 %d\n'%(self.off+posB))
            sys.stdout.write('\tsingle\tB')
            sys.stdout.flush()

            # Replace template
            if self.samples == winSize:
                self.templateB = sigs.copy()
                self.templateBsize = winSize
            self.lastCenterB = posB

            if self.lastTSB is None:
                self.lastTSB = self.off+posB
            else:
                self.lastIPIB = self.off+posB - self.lastTSB
                self.lastTSB = self.off+posB

        elif distAB <= distA and distAB <= distB:
            if jump:
                if self.off >= startOn and self.direction == onDirection: #################################
                    recogdb.writeEntry(self.db, self.off, 3, self.direction, distA, distB, distAB, 0, self.off+posA_AB, self.off+posB_AB, self.svmcause, -1, self.probA, self.probB, list(sigs.values()))
            else:
                recogdb.writeEntry(self.db, self.off, 3, self.direction, distA, distB, distAB, 0, self.off+posA_AB, self.off+posB_AB, self.svmcause, -1, self.probA, self.probB, list(sigs.values()))
            if posA < posB:
                if jump:
                    if self.off >= startOn and self.direction == onDirection: #################################
                        self.tsoutput.write('1 %d\n'%(self.off+posA_AB))
                        self.tsoutput.write('-1 %d\n'%(self.off+posB_AB))
                else:
                    self.tsoutput.write('1 %d\n'%(self.off+posA_AB))
                    self.tsoutput.write('-1 %d\n'%(self.off+posB_AB))
                sys.stdout.write('\toverlap\tAB')
                sys.stdout.flush()
            else:
                if jump:
                    if self.off >= startOn and self.direction == onDirection: #################################
                        self.tsoutput.write('-1 %d\n'%(self.off+posB_AB))
                        self.tsoutput.write('1 %d\n'%(self.off+posA_AB))
                else:
                    self.tsoutput.write('-1 %d\n'%(self.off+posB_AB))
                    self.tsoutput.write('1 %d\n'%(self.off+posA_AB))
                sys.stdout.write('\toverlap\tBA')
                sys.stdout.flush()

            if self.lastTSA is None:
                self.lastTSA = self.off+posA_AB
            else:
                self.lastIPIA = self.off+posA_AB - self.lastTSA
                self.lastTSA = self.off+posA_AB

            if self.lastTSB is None:
                self.lastTSB = self.off+posB_AB
            else:
                self.lastIPIB = self.off+posB_AB - self.lastTSB
                self.lastTSB = self.off+posB_AB

        sys.stdout.write('\n')
        sys.stdout.flush()

    def export(self):
        print('exporting data to' + self.tsoutput.name)
        P = np.zeros(2*50*3600*10) # 10h acquisition at 50 pulses per second maximum
        I = np.zeros(2*50*3600*10)
        idx = 0
        for rec in self.db.iteritems():
            key, bindata = rec
            off, = struct.unpack('q', key)
            #sys.stdout.write('\r%d'%off)
            #sys.stdout.flush()
            presentFish, direction, distA, distB, distAB, flags, correctedPosA, correctedPosB, svm, pairsvm, probA, probB, spkdata = recogdb.parseDBHeader(bindata)
            if presentFish == 1:
                P[idx] = correctedPosA
                I[idx] = 1
                idx += 1
                #self.tsoutput.write('1 %d\n'%correctedPosA)
            elif presentFish == 2:
                P[idx] = correctedPosB
                I[idx] = -1
                idx += 1
                #self.tsoutput.write('-1 %d\n'%correctedPosB)
            elif presentFish == 3:
                P[idx] = correctedPosA
                I[idx] = 1
                idx += 1
                P[idx] = correctedPosB
                I[idx] = -1
                idx += 1
                '''if correctedPosA < correctedPosB:
                    self.tsoutput.write('1 %d\n'%correctedPosA)
                    self.tsoutput.write('-1 %d\n'%correctedPosB)
                else:
                    self.tsoutput.write('-1 %d\n'%correctedPosB)
                    self.tsoutput.write('1 %d\n'%correctedPosA)'''
            else:
                print('error on presentFish DB field')
            #self.tsoutput.flush()
        print('finish DB reading operation')
        P = P[:idx]
        I = I[:idx]
        S = [i[0] for i in sorted(enumerate(P), key=lambda x:x[1])]
        from operator import itemgetter
        P = itemgetter(*S)(P)
        I = itemgetter(*S)(I)
        for i in range(idx):
            self.tsoutput.write('%d %d\n'%(I[i], P[i]))
        self.tsoutput.flush()

if __name__ == '__main__':
    description = 'Apply SVM model on spikes window file with 2 fishes'
    parser = MyParser(description=description, formatter_class=argparse.RawTextHelpFormatter)

    subparsers = parser.add_subparsers(help='Apply continuity criteria', dest='mode')

    iterate_parser = subparsers.add_parser('iterate', help='Iterate over all time series')
    iterate_parser.add_argument('db_file', type=str, help='Database file name') 
    iterate_parser.add_argument('hilb_file', type=str, help='Hilbert transform file name') 
    iterate_parser.add_argument('spikes_file', type=argparse.FileType(mode+'r'), help='Spikes window file')
    iterate_parser.add_argument('singlefish_file', type=argparse.FileType(mode+'r'), help='Singlefish file')
    iterate_parser.add_argument('probs_file', type=argparse.FileType('r'), help='Spike probability file')
    iterate_parser.add_argument('ts_output', type=argparse.FileType('a'), help='Timestamps output file')
    iterate_parser.add_argument('-z', '--saturation', type=str, help='low,high saturation levels')
    iterate_parser.add_argument('-d', '--direction', type=int, default=1, help='Scan direction (positive or negative)')

    export_parser = subparsers.add_parser('export', help='Export data from DB')
    export_parser.add_argument('db_file', type=str, help='Database file name')
    export_parser.add_argument('ts_output', type=argparse.FileType('w'), help='Timestamps output file')

    args = parser.parse_args()

    if args.mode == 'iterate':
        db = recogdb.openDB(args.db_file, 'w')
        hilbFileName = args.hilb_file
        H = np.fromfile(hilbFileName,dtype=np.float32)

        wins = winFile(args.spikes_file)
        svmpairs = np.loadtxt(args.singlefish_file, dtype=np.int64)
        svmpairsTam = svmpairs.shape[0]
        direction = args.direction
        if direction != 1:
            svmpairs = svmpairs[::-1]

        probsfile = args.probs_file
        probs = {}
        for l in probsfile.readlines():
            #cause, offstr, pairstr, probAstr, probBstr = l.strip().split(' ')
            cause, offstr, probAstr, probBstr = l.strip().split(' ')
            off = int(offstr)
            #pair = int(pairstr)
            probA = float(probAstr)
            probB = float(probBstr)
            #probs.update( {off: (cause, pair, probA, probB)} )
            probs.update( {off: (cause, probA, probB)} )


        tsoutput = args.ts_output

    if args.mode == 'export':
        db = recogdb.openDB(args.db_file, 'w')
        tsoutput = args.ts_output


    #TODO iterate_from


    r = recog()
    if args.mode == 'iterate':
        r.init_iterate(db, wins, svmpairs, svmpairsTam, probs, tsoutput)
        r.iterate(direction)

    elif args.mode == 'continue': ############### TODO: fazer init
        r.iterate(direction, cont=True)

    elif args.mode == 'export':
        r.init_export(db, tsoutput)
        r.export()
        print('')
